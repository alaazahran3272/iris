<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<title>Ù‚ÙŠØ§Ø³ Ù‚Ø·Ø± Ø§Ù„Ù‚Ø²Ø­ÙŠØ© â€” V10 (ÙƒØ§Ø±Øª ÙÙŠØ²Ø§ + ÙÙ„Ø§Ø´)</title>
<style>
  :root{--bg:#0b0f14;--fg:#e8eef6;--muted:#9fb4cc;--panel:#0f1720;--line:#1f2a36;}
  html,body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto}
  header{padding:12px;text-align:center;border-bottom:1px solid var(--line);background:var(--panel);position:sticky;top:0;z-index:3}
  main{padding:12px;max-width:1100px;margin:auto;display:grid;gap:12px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  button,input{border-radius:10px;border:1px solid #223246;background:#111b27;color:var(--fg);padding:10px 12px}
  button.primary{background:#2c7be5;border-color:#2c7be5;color:#fff}
  button.success{background:#2fbf71;border-color:#2fbf71;color:#05220e}
  button.warn{background:#f9c74f;border-color:#f9c74f;color:#3a2e00}
  input[type=range]{width:220px}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  video,canvas,img{width:100%;max-height:70vh;border-radius:12px;background:#000;object-fit:contain}
  .badge{padding:6px 10px;border-radius:999px;background:#142034;border:1px solid #24364a;font-size:.9rem}
  .muted{color:var(--muted);font-size:.9rem}
</style>
</head>
<body>
<header><h2>ğŸ§¿ Ù‚ÙŠØ§Ø³ Ù‚Ø·Ø± Ø§Ù„Ù‚Ø²Ø­ÙŠØ© â€” V10 (Ø§ÙƒØªØ´Ø§Ù Ø§Ù„ÙƒØ§Ø±Øª + ÙÙ„Ø§Ø´ + ÙƒØ´Ù ØªÙ„Ù‚Ø§Ø¦ÙŠ)</h2></header>
<main>
  <section>
    <div class="row">
      <input id="file" type="file" accept="image/*">
      <button id="toCanvas" class="primary">Ø¹Ø±Ø¶ Ø§Ù„ØµÙˆØ±Ø©</button>
      <button id="startCam" class="primary">ØªØ´ØºÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§</button>
      <button id="switchCam">ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§</button>
      <button id="torchBtn" class="warn">ØªØ´ØºÙŠÙ„ Ø§Ù„ÙÙ„Ø§Ø´</button>
      <button id="stopCam">Ø¥ÙŠÙ‚Ø§Ù</button>
      <label>Ø­Ø³Ø§Ø³ÙŠØ© Ø§Ù„Ù‚Ø²Ø­ÙŠØ©: <input id="thr" type="range" min="50" max="180" value="110"> <span id="thrV">110</span></label>
      <button id="capture" class="success">Ø§Ù„ØªÙ‚Ø§Ø·</button>
    </div>
    <div class="row">
      <span class="badge">Ø¹Ø±Ø¶ Ø§Ù„ÙƒØ§Ø±Øª Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ ÙÙŠ Ø§Ù„Ø¥Ø·Ø§Ø±Ø› Ø§Ù„ÙƒØ§Ø±Øª Ø§Ù„Ù‚ÙŠØ§Ø³ÙŠ Ø¹Ø±Ø¶Ù‡ <b>85.60 Ù…Ù…</b></span>
      <span class="badge">Ù„Ù…Ø³Ø© Ø¹Ù„Ù‰ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ/Ø§Ù„ØµÙˆØ±Ø© = ØªÙ„Ù…ÙŠØ­ Ù…ÙƒØ§Ù† Ø§Ù„Ø¹ÙŠÙ† (ROI)</span>
    </div>
  </section>

  <section class="grid2">
    <div style="position:relative">
      <video id="cam" playsinline muted></video>
      <canvas id="overlay"></canvas>
      <div class="muted">Ù…Ø¹Ø§ÙŠÙ†Ø© Ù…Ø¨Ø§Ø´Ø±Ø© (Ù„Ùˆ Ù…ØªØ§Ø­Ø©).</div>
    </div>
    <div>
      <canvas id="photo"></canvas>
      <div class="muted">Ø§Ù„ØµÙˆØ±Ø©/Ø§Ù„Ø¥Ø·Ø§Ø± + Ø§Ù„Ù‚ÙŠØ§Ø³ â€” <span id="scaleOut">px/Ù…Ù…: -</span> â€” <span id="diamOut">Ø§Ù„Ù‚Ø·Ø±: -</span></div>
      <div class="row" style="margin-top:6px">
        <button id="detectCard" class="warn">Ø§Ù„ØªÙ‚Ø§Ø· Ø§Ù„ÙƒØ§Ø±Øª ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§</button>
        <button id="detectIris" class="primary">Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ù‚Ø²Ø­ÙŠØ©</button>
      </div>
    </div>
  </section>

  <footer class="muted">V10 â€” ÙŠØ¹Ù…Ù„ Ø¹Ù„Ù‰ HTTPS. Ù„Ùˆ Ù…Ø§ Ø¸Ù‡Ø±Ø´ Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø§Ø³ØªØ®Ø¯Ù…ÙŠ ?v=10 Ø£Ùˆ Ctrl+F5.</footer>
</main>

<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
<script>
const $=s=>document.querySelector(s);
const cam=$('#cam'), overlay=$('#overlay'), octx=overlay.getContext('2d');
const photo=$('#photo'), pctx=photo.getContext('2d',{willReadFrequently:true});
let stream=null, facing='environment', imageCapture=null;
let roiHint=null, lastCircle=null, pxPerMM=null;

// === Helpers ===
function fitOverlay(){ overlay.width=cam.videoWidth||1280; overlay.height=cam.videoHeight||720; }
function haveCV(){return window.cv && cv.Mat && cv.cvtColor;}

// Load file to photo
$('#file').addEventListener('change', (e)=>{
  const f=e.target.files?.[0]; if(!f) return;
  const url=URL.createObjectURL(f);
  const img=new Image();
  img.onload=()=>{ photo.width=Math.min(1000,img.width); photo.height=Math.round(img.height*(photo.width/img.width)); pctx.drawImage(img,0,0,photo.width,photo.height); URL.revokeObjectURL(url); lastCircle=null; pxPerMM=null; updateReads(); };
  img.src=url;
});
$('#toCanvas').onclick=()=>{ /* already drawn by onchange */ };

// Camera
async function startCam(){
  try{
    stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:facing,width:{ideal:1280},height:{ideal:720}},audio:false});
    cam.srcObject=stream; await cam.play(); fitOverlay();
    const track=stream.getVideoTracks()[0];
    if('ImageCapture' in window){ try{ imageCapture=new ImageCapture(track); }catch(e){} }
    loop();
  }catch(e){ alert('ØªØ¹Ø°Ù‘Ø± ØªØ´ØºÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§: '+e.message+'\\nØªØ£ÙƒØ¯ Ù…Ù† HTTPS ÙˆØ§Ù„Ø¥Ø°Ù†.'); }
}
function stopCam(){ if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; } cam.srcObject=null; octx.clearRect(0,0,overlay.width,overlay.height); }
async function switchCam(){ facing=(facing==='user')?'environment':'user'; await startCam(); }
$('#startCam').onclick=startCam; $('#stopCam').onclick=stopCam; $('#switchCam').onclick=switchCam;

// Torch (flash) toggle (Android Chrome usually)
let torchOn=false;
$('#torchBtn').onclick=async()=>{
  try{
    const track=stream?.getVideoTracks?.()[0];
    if(!track){ alert('Ø´ØºÙ‘Ù„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø£ÙˆÙ„Ù‹Ø§'); return; }
    const caps=track.getCapabilities?.(); if(caps && 'torch' in caps){ await track.applyConstraints({advanced:[{torch:!torchOn}]}); torchOn=!torchOn; $('#torchBtn').textContent=torchOn?'Ø¥Ø·ÙØ§Ø¡ Ø§Ù„ÙÙ„Ø§Ø´':'ØªØ´ØºÙŠÙ„ Ø§Ù„ÙÙ„Ø§Ø´'; }
    else if(imageCapture && imageCapture.toggleTorch){ await imageCapture.toggleTorch(); }
    else { alert('Ø§Ù„ÙÙ„Ø§Ø´ ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ… ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ø¬Ù‡Ø§Ø²/Ø§Ù„Ù…ØªØµÙØ­.'); }
  }catch(e){ alert('ØªØ¹Ø°Ù‘Ø± Ø§Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„ÙÙ„Ø§Ø´: '+e.message); }
};

// ROI hint
function canvasXY(canvas,evt){ const r=canvas.getBoundingClientRect(); return {x:(evt.clientX-r.left)*(canvas.width/r.width), y:(evt.clientY-r.top)*(canvas.height/r.height)}; }
overlay.addEventListener('pointerdown',e=>{ roiHint = canvasXY(overlay,e); });
photo.addEventListener('pointerdown',e=>{ roiHint = canvasXY(photo,e); });

// Live loop (draw only; detection on demand to save battery)
function loop(){ const step=()=>{ if(!cam.videoWidth){ requestAnimationFrame(step); return; } octx.clearRect(0,0,overlay.width,overlay.height); if(roiHint){ octx.beginPath(); octx.arc(roiHint.x,roiHint.y,6,0,2*Math.PI); octx.fillStyle='#ffd166'; octx.fill(); } requestAnimationFrame(step); }; step(); }

$('#capture').onclick=()=>{
  if(!cam.videoWidth){ alert('Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ ØºÙŠØ± Ø¬Ø§Ù‡Ø²Ø©'); return; }
  photo.width=cam.videoWidth; photo.height=cam.videoHeight; pctx.drawImage(cam,0,0,photo.width,photo.height);
};

// === Card detection ===
function detectCard(){
  if(!haveCV()){ alert('OpenCV Ù„Ù… ÙŠØ­Ù…Ù‘Ù„ Ø¨Ø¹Ø¯'); return; }
  if(!photo.width){ alert('Ø§Ù„ØªÙ‚Ø· ØµÙˆØ±Ø© Ø£Ùˆ Ø§Ø±ÙØ¹ Ù…Ù„Ù Ø£ÙˆÙ„Ù‹Ø§'); return; }
  const CARD_MM=85.60; // width
  const src=new cv.Mat(photo.height, photo.width, cv.CV_8UC4); cv.imread(photo, src);
  const gray=new cv.Mat(); cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY);
  const blur=new cv.Mat(); cv.GaussianBlur(gray,blur,new cv.Size(5,5),0);
  const edges=new cv.Mat(); cv.Canny(blur,edges,50,150,3,false);
  const contours=new cv.MatVector(); const hierarchy=new cv.Mat();
  cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
  let best=null;
  for(let i=0;i<contours.size();i++){
    const cnt=contours.get(i);
    const peri=cv.arcLength(cnt,true);
    const approx=new cv.Mat();
    cv.approxPolyDP(cnt, approx, 0.02*peri, true);
    if(approx.rows===4){
      const rect=orderPoly(approx); // 4 points ordered
      const w = dist(rect[0],rect[1]), h = dist(rect[1],rect[2]);
      const ar = w>h? (w/h) : (h/w);
      const area=cv.contourArea(approx);
      if(area>2000 && ar>1.45 && ar<1.70){ // around 1.586
        if(!best || area>best.area){ best={rect, area, wPx:w, hPx:h}; }
      }
    }
    approx.delete(); cnt.delete();
  }
  src.delete(); gray.delete(); blur.delete(); edges.delete(); contours.delete(); hierarchy.delete();
  if(!best){ alert('Ù„Ù… Ø£Ø¬Ø¯ ÙƒØ§Ø±Øª ÙˆØ§Ø¶Ø­Ù‹Ø§. ØªØ£ÙƒØ¯ Ø£Ù† Ø§Ù„ÙƒØ§Ø±Øª ÙƒØ§Ù…Ù„ ÙˆÙˆØ§Ø¶Ø­.'); return; }
  // draw on photo
  pctx.lineWidth=3; pctx.strokeStyle='#7be27b'; pctx.beginPath();
  pctx.moveTo(best.rect[0].x, best.rect[0].y);
  for(let i=1;i<4;i++) pctx.lineTo(best.rect[i].x, best.rect[i].y);
  pctx.closePath(); pctx.stroke();
  // scale
  const cardPx = Math.max(best.wPx, best.hPx);
  pxPerMM = cardPx / CARD_MM;
  updateReads();
}
function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
function orderPoly(approx){
  const pts=[]; for(let i=0;i<4;i++){ pts.push({x:approx.intPtr(i,0)[0], y:approx.intPtr(i,0)[1]}); }
  pts.sort((p,q)=>p.x+ p.y - (q.x+q.y)); // tl â‰ˆ min sum, br â‰ˆ max sum
  const tl=pts[0], br=pts[3];
  // remaining two: choose by x to get tr, bl
  const rem=[pts[1],pts[2]].sort((a,b)=>a.x-b.x);
  const bl=rem[0].y>rem[1].y ? rem[0]:rem[1];
  const tr=rem[0].y>rem[1].y ? rem[1]:rem[0];
  return [tl,tr,br,bl];
}

// === Iris detection ===
function detectIris(){
  if(!haveCV()){ alert('OpenCV Ù„Ù… ÙŠØ­Ù…Ù‘Ù„ Ø¨Ø¹Ø¯'); return; }
  if(!photo.width){ alert('Ø§Ù„ØªÙ‚Ø· ØµÙˆØ±Ø© Ø£Ùˆ Ø§Ø±ÙØ¹ Ù…Ù„Ù Ø£ÙˆÙ„Ù‹Ø§'); return; }
  const src=new cv.Mat(photo.height, photo.width, cv.CV_8UC4); cv.imread(photo, src);
  let gray=new cv.Mat(); cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY); src.delete();
  const clahe=new cv.CLAHE(3.0,new cv.Size(8,8)); const eq=new cv.Mat(); clahe.apply(gray,eq); gray.delete(); clahe.delete();
  const blur=new cv.Mat(); cv.medianBlur(eq,blur,5); eq.delete();
  let roi=blur, x0=0, y0=0;
  if(roiHint){ const size=Math.round(Math.min(photo.width,photo.height)*0.4); x0=Math.max(0,Math.min(photo.width-size,Math.round(roiHint.x-size/2))); y0=Math.max(0,Math.min(photo.height-size,Math.round(roiHint.y-size/2))); roi = blur.roi(new cv.Rect(x0,y0,size,size)); }
  const circles=new cv.Mat();
  const dp=1.2; const minDist=Math.round(Math.min(roi.cols,roi.rows)/6);
  const p1=160; const p2=parseInt($('#thr').value);
  const minR=Math.round(Math.min(roi.cols,roi.rows)*0.07); const maxR=Math.round(Math.min(roi.cols,roi.rows)*0.35);
  cv.HoughCircles(roi,circles,cv.HOUGH_GRADIENT,dp,minDist,p1,p2,minR,maxR);
  lastCircle=null;
  if(circles.cols>0){ const cx=circles.data32F[0]+x0, cy=circles.data32F[1]+y0, r=circles.data32F[2]; lastCircle={x:cx,y:cy,r:r}; }
  blur.delete(); if(roi!==blur){} circles.delete();
  // draw
  if(lastCircle){ pctx.beginPath(); pctx.arc(lastCircle.x,lastCircle.y,lastCircle.r,0,2*Math.PI); pctx.lineWidth=3; pctx.strokeStyle='#2c7be5'; pctx.stroke(); }
  updateReads();
}
$('#thr').oninput=(e)=>$('#thrV').textContent=e.target.value;

function updateReads(){
  if(pxPerMM){ $('#scaleOut').textContent='px/Ù…Ù…: '+pxPerMM.toFixed(2); } else { $('#scaleOut').textContent='px/Ù…Ù…: -'; }
  if(lastCircle){
    const dpx = 2*lastCircle.r;
    if(pxPerMM){ $('#diamOut').textContent='Ø§Ù„Ù‚Ø·Ø±: '+(dpx/pxPerMM).toFixed(2)+' Ù…Ù…'; }
    else { $('#diamOut').textContent='Ø§Ù„Ù‚Ø·Ø± (px): '+dpx.toFixed(1)+' â€” Ø§Ù„ØªÙ‚Ø· Ø§Ù„ÙƒØ§Ø±Øª Ø£ÙˆÙ„Ù‹Ø§'; }
  } else { $('#diamOut').textContent='Ø§Ù„Ù‚Ø·Ø±: -'; }
}

$('#detectCard').onclick=detectCard;
$('#detectIris').onclick=detectIris;
</script>
</body>
</html>
