<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<title>Ù‚ÙŠØ§Ø³ Ù‚Ø·Ø± Ø§Ù„Ù‚Ø²Ø­ÙŠØ© â€” V8.3 (ØªØ­Ø³ÙŠÙ† ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù‚ÙˆÙŠ + Ù…Ø±Ø´Ø­ÙŠÙ†)</title>
<style>
  :root { --pad: 12px; --radius: 12px; }
  html, body { margin:0; padding:0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Naskh Arabic UI", "Helvetica Neue", Arial, "Noto Color Emoji", sans-serif; background:#0b0f14; color:#e8eef6; }
  header { padding: var(--pad); text-align:center; background:#0f1720; position:sticky; top:0; z-index:5; border-bottom:1px solid #1f2a36; }
  header h1 { margin:0; font-size: 1.1rem; }
  main { padding: var(--pad); display: grid; gap: 16px; max-width: 1100px; margin: 0 auto; }
  section { background:#0f1720; border:1px solid #1f2a36; border-radius: var(--radius); padding: var(--pad); }
  .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  label { font-size: .9rem; opacity:.9; }
  input, select, textarea, button { border-radius: 10px; border:1px solid #223246; background:#111b27; color:#e8eef6; padding:10px 12px; font-size:16px; }
  input:focus, textarea:focus, button:focus { outline: 2px solid #2c7be5; }
  button { cursor:pointer; }
  button.primary { background:#2c7be5; border-color:#2c7be5; color:white; }
  button.success { background:#2fbf71; border-color:#2fbf71; color:#05220e; }
  button.warn { background:#f9c74f; border-color:#f9c74f; color:#3a2e00; }
  button.ghost { background:transparent; }
  .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
  .grid3 { display:grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
  .badge { padding:6px 10px; border-radius:999px; background:#142034; border:1px solid #24364a; font-size:.9rem; }
  .muted { color:#9fb4cc; font-size:.9rem; }
  canvas, img.preview { width: 100%; max-height: 70vh; border-radius: 12px; background:#02060a; object-fit: contain; touch-action: none; }
  .controls { display:grid; grid-template-columns: 1fr; gap: 10px; }
  .slider-row { display:flex; align-items:center; gap:8px; }
  .slider-row input[type=range] { width: 260px; }
  .cands { display:flex; gap:8px; flex-wrap:wrap; }
  .cand { padding:6px 10px; border:1px dashed #2c7be5; border-radius:999px; cursor:pointer; }
  .cand:hover { background:#112133; }
  .pill { padding:6px 10px; border:1px solid #2c7be5; border-radius:999px; }
  @media (max-width: 820px){ .grid2 { grid-template-columns: 1fr; } }
</style>
</head>
<body>
  <header>
    <h1>ğŸ§¿ Ù‚ÙŠØ§Ø³ Ù‚Ø·Ø± Ø§Ù„Ù‚Ø²Ø­ÙŠØ© â€” V8.3 (ØªØ­Ø³ÙŠÙ† ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù‚ÙˆÙŠ + Ù…Ø±Ø´Ø­ÙŠÙ†)</h1>
  </header>

  <main>
    <section class="controls">
      <div class="row">
        <input id="file" type="file" accept="image/*">
        <button id="btnToCanvas" class="primary">Ø¹Ø±Ø¶ Ø¹Ù„Ù‰ Ø§Ù„Ù„ÙˆØ­Ø©</button>
        <button id="btnAutoAll" class="success">Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ù‚Ø²Ø­ÙŠØ© + Ù…Ù„Ù…</button>
        <button id="btnAutoStrong" class="warn">ØªØ¬Ø±Ø¨Ø© Ù‚ÙˆÙŠØ© (Ù„Ùˆ ÙØ´Ù„ Ø§Ù„Ø¹Ø§Ø¯ÙŠ)</button>
        <button id="btnAutoRuler" class="ghost">Ø§Ù„ØªÙ‚Ø§Ø· Ø®Ø· Ø§Ù„Ù…Ø³Ø·Ø±Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§</button>
        <span class="pill">Ø§Ø®ØªÙŠØ§Ø±ÙŠ: Ø§Ø¶ØºØ·ÙŠ Ù‚Ø±Ø¨ Ø§Ù„Ø¹ÙŠÙ† Ù„ØªØ­Ø¯ÙŠØ¯ <b>Ù…Ø±ÙƒØ² ØªÙ‚Ø±ÙŠØ¨ÙŠ</b> Ù‚Ø¨Ù„ Ø§Ù„Ø§ÙƒØªØ´Ø§Ù</span>
      </div>
      <div class="slider-row">
        <button id="minus">âˆ’</button>
        <input id="radiusSlider" type="range" min="5" max="500" value="60">
        <button id="plus">+</button>
        <span id="radiusOut" class="badge">Ù†ØµÙ Ø§Ù„Ù‚Ø·Ø±(px): 60</span>
        <span id="pxOut" class="badge">px/Ù…Ù…: -</span>
        <span id="diameterOut" class="badge">Ø§Ù„Ù‚Ø·Ø±: -</span>
      </div>
      <div class="row">
        <span>Ø·ÙˆÙ„ Ø§Ù„Ù…Ø±Ø¬Ø¹ (Ù…Ù…):</span>
        <input id="knownMM" type="number" step="0.01" value="10" style="width:110px">
        <button id="resetLine">Ù…Ø³Ø­ Ø®Ø· Ø§Ù„Ù…Ø¹Ø§ÙŠØ±Ø©</button>
        <span class="muted">ØªÙ‚Ø¯Ø±Ù ØªØºÙŠØ±ÙŠ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø­Ø³Ø¨ Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ø°ÙŠ ØªÙ„ØªÙ‚Ø·Ù‡ Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© (Ù…Ø«Ù„Ø§Ù‹ 10 Ù…Ù…).</span>
      </div>
      <div id="candWrap" class="row" style="display:none;">
        <span class="muted">Ø§Ø®ØªØ±/ÙŠ Ù…Ù† Ø§Ù„Ù…Ø±Ø´Ø­ÙŠÙ†:</span>
        <div id="candList" class="cands"></div>
      </div>
    </section>

    <section id="work">
      <div class="grid2" style="margin-top:10px;">
        <img id="preview" class="preview" alt="Ù…Ø¹Ø§ÙŠÙ†Ø© (Ù‚Ø¨Ù„ Ø§Ù„Ø±Ø³Ù…)">
        <canvas id="photo"></canvas>
      </div>
      <div id="errorMsg" class="muted" style="color:#ff8a8a;"></div>
    </section>

    <footer class="muted">Â© 2025 â€” V8.3 â€¢ Ù„Ùˆ Ù…Ø§ Ø¸Ù‡Ø±Ø´ Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø§ÙØªØ­ Ø§Ù„Ø±Ø§Ø¨Ø· ÙˆÙÙŠ Ø¢Ø®Ø±Ù‡ <code>?v=8.3</code> Ø£Ùˆ Ctrl+F5</footer>
  </main>

  <!-- OpenCV.js CDN -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>

  <script>
    const $ = (sel) => document.querySelector(sel);
    const photo = $('#photo');
    const preview = $('#preview');
    const ctx = photo.getContext('2d', { willReadFrequently: true });

    let baseCanvas = null;
    let lastCircle = null;   // {x,y,r}
    let calibLine = null;    // {x1,y1,x2,y2}
    let scalePxPerMM = null;
    let drag = {mode:null, start:null, startCircle:null};
    let roiHint = null;      // {x,y} Ù…Ù† Ù†Ù‚Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„Ù‚Ø±Ø¨ Ù…Ù† Ø§Ù„Ø¹ÙŠÙ†
    const HANDLE_R = 18;

    function getCanvasXY(evt){
      const rect = photo.getBoundingClientRect();
      const sx = photo.width / rect.width;
      const sy = photo.height / rect.height;
      return { x: (evt.clientX - rect.left) * sx, y: (evt.clientY - rect.top) * sy };
    }
    function redraw(){
      if(!baseCanvas) return;
      ctx.clearRect(0,0,photo.width,photo.height);
      ctx.drawImage(baseCanvas, 0, 0);
      if(calibLine){
        ctx.beginPath(); ctx.moveTo(calibLine.x1, calibLine.y1); ctx.lineTo(calibLine.x2, calibLine.y2);
        ctx.strokeStyle='#7be27b'; ctx.lineWidth=3; ctx.stroke();
      }
      if(lastCircle){
        ctx.beginPath(); ctx.arc(lastCircle.x,lastCircle.y,lastCircle.r,0,Math.PI*2);
        ctx.lineWidth=2; ctx.strokeStyle='#2c7be5'; ctx.stroke();
        ctx.beginPath(); ctx.arc(lastCircle.x,lastCircle.y,6,0,Math.PI*2);
        ctx.fillStyle='#7be27b'; ctx.fill();
      }
      if(roiHint){
        ctx.beginPath(); ctx.arc(roiHint.x, roiHint.y, 6, 0, Math.PI*2);
        ctx.fillStyle='#ffd166'; ctx.fill();
      }
    }
    function updateReadouts(){
      if(!lastCircle){ $('#radiusOut').textContent='Ù†ØµÙ Ø§Ù„Ù‚Ø·Ø±(px): -'; $('#diameterOut').textContent='Ø§Ù„Ù‚Ø·Ø±: -'; return; }
      $('#radiusOut').textContent = 'Ù†ØµÙ Ø§Ù„Ù‚Ø·Ø±(px): ' + lastCircle.r.toFixed(1);
      const dpx = 2*lastCircle.r;
      $('#diameterOut').textContent = scalePxPerMM ? ('Ø§Ù„Ù‚Ø·Ø±: '+(dpx/scalePxPerMM).toFixed(2)+' Ù…Ù…') : ('Ø§Ù„Ù‚Ø·Ø± (px): '+dpx.toFixed(1)+' â€” Ø¹Ø§ÙŠØ±ÙŠ Ù„Ù„ØªØ­ÙˆÙŠÙ„');
    }

    // ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©
    $('#file').addEventListener('change', (ev)=>{
      const f = ev.target.files && ev.target.files[0];
      if(!f){ return; }
      const url = URL.createObjectURL(f);
      preview.src = url;
    });
    $('#btnToCanvas').addEventListener('click', ()=>{
      if(!preview.src){ alert('Ø§Ø®ØªØ§Ø±ÙŠ ØµÙˆØ±Ø© Ø£ÙˆÙ„Ù‹Ø§'); return; }
      const img = new Image();
      img.onload = ()=>{
        const maxW = 1000;
        const scale = Math.min(1, maxW / img.width);
        const w = Math.max(1, Math.round(img.width*scale));
        const h = Math.max(1, Math.round(img.height*scale));
        photo.width=w; photo.height=h;
        baseCanvas = document.createElement('canvas');
        baseCanvas.width=w; baseCanvas.height=h;
        baseCanvas.getContext('2d').drawImage(img,0,0,w,h);
        lastCircle = {x:w/2, y:h/2, r: Math.min(w,h)/8};
        calibLine=null; scalePxPerMM=null; roiHint=null;
        $('#pxOut').textContent='px/Ù…Ù…: -';
        $('#radiusSlider').max = Math.round(Math.min(w,h)/1.5);
        $('#radiusSlider').value = Math.round(lastCircle.r);
        $('#candWrap').style.display='none'; $('#candList').innerHTML='';
        redraw(); updateReadouts();
      };
      img.src = preview.src;
    });

    // ÙˆØ¶Ø¹ Ø³Ù‡Ù„: Ù„Ù…Ø³/ÙƒÙ„ÙŠÙƒ = ØªØ­Ø¯ÙŠØ¯ Ù…Ø±ÙƒØ² ÙˆØªØ­Ø±ÙŠÙƒ + Ù…Ù…ÙƒÙ† ROI hint
    photo.addEventListener('pointerdown', (e)=>{
      if(!baseCanvas) return;
      const pos = getCanvasXY(e);
      // Ø³Ø¬Ù‘Ù„ÙŠ Ø¥Ø´Ø§Ø±Ø© ROI ÙƒÙ†Ù‚Ø·Ø© Ù‚Ø±ÙŠØ¨Ø© Ù…Ù† Ø§Ù„Ø¹ÙŠÙ† Ù„Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© ÙÙŠ Ø§Ù„Ø§ÙƒØªØ´Ø§Ù
      roiHint = pos; redraw();
      const inside = lastCircle && Math.hypot(pos.x-lastCircle.x,pos.y-lastCircle.y) <= lastCircle.r + HANDLE_R;
      if(inside){
        drag.mode = 'move'; drag.start = pos; drag.startCircle = {...lastCircle};
      }else{
        lastCircle = lastCircle || {x:pos.x,y:pos.y,r:60};
        lastCircle.x = pos.x; lastCircle.y = pos.y;
        redraw(); updateReadouts();
        drag.mode = 'move'; drag.start = pos; drag.startCircle = {...lastCircle};
      }
    });
    photo.addEventListener('pointermove', (e)=>{
      if(!baseCanvas) return;
      const pos = getCanvasXY(e);
      if(drag.mode === 'move' && drag.startCircle){
        lastCircle.x = drag.startCircle.x + (pos.x - drag.start.x);
        lastCircle.y = drag.startCircle.y + (pos.y - drag.start.y);
        redraw(); updateReadouts();
      }
    });
    photo.addEventListener('pointerup', ()=>{ drag = {mode:null,start:null,startCircle:null}; });

    // Slider Â±
    $('#radiusSlider').addEventListener('input', (e)=>{
      if(!lastCircle) return;
      lastCircle.r = parseInt(e.target.value||'0')||0;
      redraw(); updateReadouts();
    });
    $('#minus').addEventListener('click', ()=>{
      const s = $('#radiusSlider'); s.value = Math.max(parseInt(s.min), parseInt(s.value)-2); s.dispatchEvent(new Event('input'));
    });
    $('#plus').addEventListener('click', ()=>{
      const s = $('#radiusSlider'); s.value = Math.min(parseInt(s.max), parseInt(s.value)+2); s.dispatchEvent(new Event('input'));
    });

    // Ù…Ø¹Ø§ÙŠØ±Ø© ÙŠØ¯ÙˆÙŠØ©
    function computeScaleFromLine(line){
      const dx = line.x2 - line.x1;
      const dy = line.y2 - line.y1;
      const px = Math.hypot(dx,dy);
      const mm = parseFloat($('#knownMM').value||'0');
      if(mm > 0 && px > 5){
        scalePxPerMM = px/mm;
        $('#pxOut').textContent = 'px/Ù…Ù…: ' + scalePxPerMM.toFixed(2);
        updateReadouts();
      }
    }
    $('#resetLine').addEventListener('click', ()=>{ calibLine=null; scalePxPerMM=null; $('#pxOut').textContent='px/Ù…Ù…: -'; redraw(); updateReadouts(); });

    // ===== Helpers: OpenCV preprocessing =====
    function claheGray(canvas){
      const w = canvas.width, h = canvas.height;
      const src = new cv.Mat(h, w, cv.CV_8UC4);
      cv.imread(canvas, src);
      const gray = new cv.Mat(); cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY); src.delete();
      // CLAHE
      const clahe = new cv.CLAHE(3.0, new cv.Size(8,8));
      const eq = new cv.Mat(); clahe.apply(gray, eq); gray.delete(); clahe.delete();
      return eq; // CV_8UC1
    }

    function cropByRoiHint(mat, hint, scale=0.5){
      // crop square area around hint to speed up & be robust
      if(!hint) return {roi:mat, x0:0, y0:0};
      const w = mat.cols, h = mat.rows;
      const size = Math.round(Math.min(w,h) * scale);
      const x0 = Math.max(0, Math.min(w - size, Math.round(hint.x - size/2)));
      const y0 = Math.max(0, Math.min(h - size, Math.round(hint.y - size/2)));
      const rect = new cv.Rect(x0, y0, size, size);
      return {roi: mat.roi(rect), x0, y0};
    }

    // ===== Iris detection: normal & strong =====
    async function detectIris(strong=false){
      if(!window.cv || !cv.cvtColor){ alert('OpenCV Ù„Ù… ÙŠØ­Ù…Ù‘Ù„ Ø¨Ø¹Ø¯'); return null; }
      const w = photo.width, h = photo.height;
      if(!w || !h){ alert('Ø§Ø¹Ù…Ù„ÙŠ "Ø¹Ø±Ø¶ Ø¹Ù„Ù‰ Ø§Ù„Ù„ÙˆØ­Ø©" Ø£ÙˆÙ„Ù‹Ø§'); return null; }

      let gray = claheGray(photo); // contrast enhanced

      // If strong, use bilateral to reduce texture while keeping edges
      let work = new cv.Mat();
      if(strong){
        cv.bilateralFilter(gray, work, 9, 75, 75);
      } else {
        cv.medianBlur(gray, work, 5);
      }
      gray.delete();

      // ROI crop if user hinted
      const {roi, x0, y0} = cropByRoiHint(work, roiHint, strong?0.7:0.55);
      work.delete();

      // multi-sweep Hough
      const cands = [];
      const minR = Math.round(Math.min(roi.cols, roi.rows) * 0.06);
      const maxR = Math.round(Math.min(roi.cols, roi.rows) * 0.35);
      const params2 = strong ? [120,110,100,90,80,70,60] : [120,100,90,80];
      const dps = strong ? [1.2,1.0] : [1.2];
      for(const dp of dps){
        for(const p2 of params2){
          const circles = new cv.Mat();
          try{
            cv.HoughCircles(roi, circles, cv.HOUGH_GRADIENT, dp, Math.round(Math.min(roi.cols,roi.rows)/6), 160, p2, minR, maxR);
            for (let i = 0; i < circles.cols; ++i) {
              const x = circles.data32F[i*3] + x0;
              const y = circles.data32F[i*3+1] + y0;
              const r = circles.data32F[i*3+2];
              cands.push({x,y,r, score:p2});
            }
          } finally { circles.delete(); }
        }
      }
      roi.delete();

      if(!cands.length) return null;

      // Sort by closeness to roiHint (if exists) & penalty by off-center
      cands.sort((a,b)=>{
        const ca = roiHint ? Math.hypot(a.x-roiHint.x, a.y-roiHint.y) : Math.abs(a.x-w/2)+Math.abs(a.y-h/2);
        const cb = roiHint ? Math.hypot(b.x-roiHint.x, b.y-roiHint.y) : Math.abs(b.x-w/2)+Math.abs(b.y-h/2);
        return ca - cb;
      });

      return cands.slice(0,6); // return top candidates
    }

    function showCandidates(cands){
      const wrap = $('#candWrap'), list = $('#candList');
      list.innerHTML=''; wrap.style.display='flex';
      cands.forEach((c,idx)=>{
        const el = document.createElement('button');
        el.className='cand';
        el.textContent = `Ù…Ø±Ø´Ø­ ${idx+1} â€” r=${c.r.toFixed(1)}px`;
        el.onclick = ()=>{ lastCircle = c; redraw(); updateReadouts(); };
        list.appendChild(el);
      });
    }

    async function autoAll(){
      const cands = await detectIris(false);
      if(!cands){
        alert('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¯Ø§Ø¦Ø±Ø© Ù…Ù†Ø§Ø³Ø¨Ø© â€” Ø¬Ø±Ø¨ÙŠ "ØªØ¬Ø±Ø¨Ø© Ù‚ÙˆÙŠØ©" Ø£Ùˆ Ø§Ø¶ØºØ·ÙŠ Ù‚Ø±Ø¨ Ø§Ù„Ø¹ÙŠÙ† Ø«Ù… Ø£Ø¹ÙŠØ¯ÙŠ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©.');
        return;
      }
      showCandidates(cands);
      lastCircle = cands[0]; redraw(); updateReadouts();
      if(scalePxPerMM){ /* already calibrated */ } else { /* try auto ruler to complete mm */ await autoRuler(false); updateReadouts(); }
    }
    async function autoStrong(){
      const cands = await detectIris(true);
      if(!cands){
        alert('Ø­ØªÙ‰ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù‚ÙˆÙŠ Ù„Ù… ÙŠØ¬Ø¯ Ø¯Ø§Ø¦Ø±Ø© â€” Ø§Ø³ØªØ®Ø¯Ù…ÙŠ ÙˆØ¶Ø¹ Ø³Ù‡Ù„ ÙˆØ§Ø¶Ø¨Ø·ÙŠ Ø§Ù„Ø­Ø¬Ù… ÙŠØ¯ÙˆÙŠÙ‹Ø§ Ø«Ù… Ø§Ø­Ø³Ø¨ÙŠ.');
        return;
      }
      showCandidates(cands);
      lastCircle = cands[0]; redraw(); updateReadouts();
      if(scalePxPerMM){ } else { await autoRuler(true); updateReadouts(); }
    }

    // ===== Ruler detection with candidates =====
    async function autoRuler(verbose=true){
      if(!window.cv || !cv.cvtColor){ if(verbose) alert('OpenCV Ù„Ù… ÙŠØ­Ù…Ù‘Ù„ Ø¨Ø¹Ø¯'); return; }
      const w = photo.width, h = photo.height;
      if(!w || !h){ if(verbose) alert('Ø§Ø¹Ù…Ù„ÙŠ "Ø¹Ø±Ø¶ Ø¹Ù„Ù‰ Ø§Ù„Ù„ÙˆØ­Ø©" Ø£ÙˆÙ„Ù‹Ø§'); return; }

      const src = new cv.Mat(h, w, cv.CV_8UC4); cv.imread(photo, src);
      const gray = new cv.Mat(); cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
      const blur = new cv.Mat(); cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0);
      const edges1 = new cv.Mat(); cv.Canny(blur, edges1, 40, 120, 3, false);
      const edges2 = new cv.Mat(); cv.Canny(blur, edges2, 20, 80, 3, false);
      const lines = new cv.Mat();
      const all = [];

      function collect(mat, thr, minLenK=0.12){
        cv.HoughLinesP(mat, lines, 1, Math.PI/180, thr, Math.round(w*minLenK), Math.round(w*0.008));
        for (let i = 0; i < lines.rows; ++i) {
          const x1 = lines.data32S[i*4], y1 = lines.data32S[i*4+1], x2 = lines.data32S[i*4+2], y2 = lines.data32S[i*4+3];
          const dx = x2 - x1, dy = y2 - y1;
          const len = Math.hypot(dx,dy);
          const slopeOK = Math.abs(dy) <= Math.abs(dx) * 0.25; // Ø£ÙÙ‚ÙŠ ØªÙ‚Ø±ÙŠØ¨Ù‹Ø§
          const inTop = ((y1 + y2)/2) < h*0.75; // Ø£Ø¹Ù„Ù‰ 3/4
          if(slopeOK && inTop) all.push({x1,y1,x2,y2,len});
        }
      }
      collect(edges1, 80, 0.12);
      collect(edges2, 60, 0.10);

      src.delete(); gray.delete(); blur.delete(); edges1.delete(); edges2.delete(); lines.delete();

      if(!all.length){ if(verbose) alert('Ù„Ù… Ø£Ø³ØªØ·Ø¹ Ø§Ù„ØªÙ‚Ø§Ø· Ø®Ø· Ø§Ù„Ù…Ø³Ø·Ø±Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§.'); return; }

      all.sort((a,b)=> b.len - a.len);
      const top = all.slice(0,6);

      // Ø§Ø±Ø³Ù… Ø§Ù„Ø£ÙˆÙ„ Ø§ÙØªØ±Ø§Ø¶ÙŠÙ‹Ø§ ÙˆØ§Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø±Ø´Ø­ÙŠÙ†
      calibLine = top[0]; redraw(); computeScaleFromLine(calibLine);

      // Ù‚Ø§Ø¦Ù…Ø© Ù…Ø±Ø´Ø­ÙŠÙ† Ù„Ù„Ø§Ø®ØªÙŠØ§Ø±
      const wrap = $('#candWrap'), list = $('#candList');
      list.innerHTML=''; wrap.style.display='flex';
      top.forEach((ln,idx)=>{
        const el = document.createElement('button');
        el.className='cand';
        el.textContent = `Ø®Ø· ${idx+1} â€” Ø·ÙˆÙ„ ${ln.len.toFixed(0)}px`;
        el.onclick = ()=>{ calibLine = ln; redraw(); computeScaleFromLine(ln); };
        list.appendChild(el);
      });
    }

    // Ø²Ø±Ø§Ø±
    $('#btnAutoAll').addEventListener('click', autoAll);
    $('#btnAutoStrong').addEventListener('click', autoStrong);
    $('#btnAutoRuler').addEventListener('click', ()=>autoRuler(true));

  </script>
</body>
</html>
