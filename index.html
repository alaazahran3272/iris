<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<title>قياس قطر القزحية — V8.2 (التقاط خط المسطرة تلقائيًا)</title>
<style>
  :root { --pad: 12px; --radius: 12px; }
  html, body { margin:0; padding:0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Naskh Arabic UI", "Helvetica Neue", Arial, "Noto Color Emoji", sans-serif; background:#0b0f14; color:#e8eef6; }
  header { padding: var(--pad); text-align:center; background:#0f1720; position:sticky; top:0; z-index:5; border-bottom:1px solid #1f2a36; }
  header h1 { margin:0; font-size: 1.1rem; }
  main { padding: var(--pad); display: grid; gap: 16px; max-width: 980px; margin: 0 auto; }
  section { background:#0f1720; border:1px solid #1f2a36; border-radius: var(--radius); padding: var(--pad); }
  .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  label { font-size: .9rem; opacity:.9; }
  input, select, textarea, button { border-radius: 10px; border:1px solid #223246; background:#111b27; color:#e8eef6; padding:10px 12px; font-size:16px; }
  input:focus, textarea:focus, button:focus { outline: 2px solid #2c7be5; }
  button { cursor:pointer; }
  button.primary { background:#2c7be5; border-color:#2c7be5; color:white; }
  button.success { background:#2fbf71; border-color:#2fbf71; color:#05220e; }
  button.ghost { background:transparent; }
  .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
  .badge { padding:6px 10px; border-radius:999px; background:#142034; border:1px solid #24364a; font-size:.9rem; }
  .muted { color:#9fb4cc; font-size:.9rem; }
  canvas, img.preview { width: 100%; max-height: 70vh; border-radius: 12px; background:#02060a; object-fit: contain; touch-action: none; }
  .controls { display:grid; grid-template-columns: 1fr; gap: 10px; }
  .slider-row { display:flex; align-items:center; gap:8px; }
  .slider-row input[type=range] { width: 260px; }
  @media (max-width: 680px){ .grid2 { grid-template-columns: 1fr; } }
</style>
</head>
<body>
  <header>
    <h1>🧿 قياس قطر القزحية — V8.2 (التقاط خط المسطرة تلقائيًا)</h1>
  </header>

  <main>
    <section class="controls">
      <div class="row">
        <input id="file" type="file" accept="image/*">
        <button id="btnToCanvas" class="primary">عرض على اللوحة</button>
        <button id="btnAutoAll" class="success">اكتشاف القزحية + ملم</button>
        <button id="btnAutoRuler" class="ghost">التقاط خط المسطرة تلقائيًا</button>
      </div>
      <div class="row">
        <span class="badge">اضغطي/المسي على القزحية لوضع المركز</span>
        <span class="badge">اسحبي في أي مكان للتحريك — كبّري/صغّري بالشريط أو Pinch</span>
      </div>
      <div class="slider-row">
        <button id="minus">−</button>
        <input id="radiusSlider" type="range" min="5" max="400" value="60">
        <button id="plus">+</button>
        <span id="radiusOut" class="badge">نصف القطر(px): 60</span>
      </div>
      <div class="row">
        <span>طول المرجع (مم):</span>
        <input id="knownMM" type="number" step="0.01" value="10" style="width:110px">
        <button id="resetLine">مسح خط المعايرة</button>
        <span class="muted">يمكنك تغيير القيمة حسب طول الجزء الذي ستلتقطه الخوارزمية (مثلاً 10 مم).</span>
      </div>
      <div class="row">
        <span id="pxOut" class="badge">px/مم: -</span>
        <span id="diameterOut" class="badge">القطر: -</span>
      </div>
    </section>

    <section id="work">
      <div class="grid2" style="margin-top:10px;">
        <img id="preview" class="preview" alt="معاينة (قبل الرسم)">
        <canvas id="photo"></canvas>
      </div>
      <div id="errorMsg" class="muted" style="color:#ff8a8a;"></div>
    </section>

    <footer class="muted">© 2025 — V8.2 • لو ما ظهرش التحديث افتح الرابط وفي آخره <code>?v=8.2</code> أو Ctrl+F5</footer>
  </main>

  <!-- OpenCV.js CDN -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>

  <script>
    const $ = (sel) => document.querySelector(sel);
    const photo = $('#photo');
    const preview = $('#preview');
    const ctx = photo.getContext('2d', { willReadFrequently: true });

    let baseCanvas = null;   // صورة الأساس
    let lastCircle = null;   // {x,y,r}
    let calibLine = null;    // {x1,y1,x2,y2,dragging}
    let scalePxPerMM = null; // px per mm
    let drag = {mode:null, start:null, startCircle:null};
    const HANDLE_R = 18;

    function getCanvasXY(evt){
      const rect = photo.getBoundingClientRect();
      const sx = photo.width / rect.width;
      const sy = photo.height / rect.height;
      return { x: (evt.clientX - rect.left) * sx, y: (evt.clientY - rect.top) * sy };
    }
    function redraw(){
      if(!baseCanvas) return;
      ctx.clearRect(0,0,photo.width,photo.height);
      ctx.drawImage(baseCanvas, 0, 0);
      // خط المعايرة
      if(calibLine){
        ctx.beginPath(); ctx.moveTo(calibLine.x1, calibLine.y1); ctx.lineTo(calibLine.x2, calibLine.y2);
        ctx.strokeStyle='#7be27b'; ctx.lineWidth=3; ctx.stroke();
      }
      // الدائرة
      if(lastCircle){
        ctx.beginPath(); ctx.arc(lastCircle.x,lastCircle.y,lastCircle.r,0,Math.PI*2);
        ctx.lineWidth=2; ctx.strokeStyle='#2c7be5'; ctx.stroke();
        // مركز
        ctx.beginPath(); ctx.arc(lastCircle.x,lastCircle.y,6,0,Math.PI*2);
        ctx.fillStyle='#7be27b'; ctx.fill();
      }
    }
    function updateReadouts(){
      if(!lastCircle){ $('#radiusOut').textContent='نصف القطر(px): -'; $('#diameterOut').textContent='القطر: -'; return; }
      $('#radiusOut').textContent = 'نصف القطر(px): ' + lastCircle.r.toFixed(1);
      const dpx = 2*lastCircle.r;
      $('#diameterOut').textContent = scalePxPerMM ? ('القطر: '+(dpx/scalePxPerMM).toFixed(2)+' مم') : ('القطر (px): '+dpx.toFixed(1)+' — عايري أو استخدمي التقاط المسطرة');
    }

    // تحميل الصورة
    $('#file').addEventListener('change', (ev)=>{
      const f = ev.target.files && ev.target.files[0];
      if(!f){ return; }
      const url = URL.createObjectURL(f);
      preview.src = url;
    });
    $('#btnToCanvas').addEventListener('click', ()=>{
      if(!preview.src){ alert('اختاري صورة أولًا'); return; }
      const img = new Image();
      img.onload = ()=>{
        const maxW = 900;
        const scale = Math.min(1, maxW / img.width);
        const w = Math.max(1, Math.round(img.width*scale));
        const h = Math.max(1, Math.round(img.height*scale));
        photo.width=w; photo.height=h;
        baseCanvas = document.createElement('canvas');
        baseCanvas.width=w; baseCanvas.height=h;
        baseCanvas.getContext('2d').drawImage(img,0,0,w,h);
        lastCircle = {x:w/2, y:h/2, r: Math.min(w,h)/8};
        calibLine=null; scalePxPerMM=null;
        $('#pxOut').textContent='px/مم: -';
        $('#radiusSlider').max = Math.round(Math.min(w,h)/1.5);
        $('#radiusSlider').value = Math.round(lastCircle.r);
        redraw(); updateReadouts();
      };
      img.src = preview.src;
    });

    // لمس/كليك = تحديد مركز وتحريك
    photo.addEventListener('pointerdown', (e)=>{
      if(!baseCanvas) return;
      const pos = getCanvasXY(e);
      if(e.shiftKey){ calibLine = {x1:pos.x,y1:pos.y,x2:pos.x,y2:pos.y,dragging:true}; redraw(); return; }
      const inside = lastCircle && Math.hypot(pos.x-lastCircle.x,pos.y-lastCircle.y) <= lastCircle.r + HANDLE_R;
      if(inside){
        drag.mode = 'move'; drag.start = pos; drag.startCircle = {...lastCircle};
      }else{
        lastCircle = lastCircle || {x:pos.x,y:pos.y,r:60};
        lastCircle.x = pos.x; lastCircle.y = pos.y;
        redraw(); updateReadouts();
        drag.mode = 'move'; drag.start = pos; drag.startCircle = {...lastCircle};
      }
    });
    photo.addEventListener('pointermove', (e)=>{
      if(!baseCanvas) return;
      const pos = getCanvasXY(e);
      if(drag.mode === 'move' && drag.startCircle){
        lastCircle.x = drag.startCircle.x + (pos.x - drag.start.x);
        lastCircle.y = drag.startCircle.y + (pos.y - drag.start.y);
        redraw(); updateReadouts();
      }
      if(calibLine && calibLine.dragging){
        calibLine.x2 = pos.x; calibLine.y2 = pos.y; redraw();
      }
    });
    photo.addEventListener('pointerup', ()=>{
      if(calibLine && calibLine.dragging){ calibLine.dragging=false; computeScale(); }
      drag = {mode:null,start:null,startCircle:null};
    });

    // Pinch
    const pointers = new Map();
    photo.addEventListener('pointerdown', (e)=>{ pointers.set(e.pointerId, getCanvasXY(e)); });
    photo.addEventListener('pointermove', (e)=>{
      if(!pointers.has(e.pointerId)) return;
      pointers.set(e.pointerId, getCanvasXY(e));
      if(pointers.size === 2 && lastCircle){
        const [p1,p2] = Array.from(pointers.values());
        const d = Math.hypot(p1.x-p2.x,p1.y-p2.y);
        if(!photo._pinchStart){ photo._pinchStart = d; photo._r0 = lastCircle.r; }
        const scale = d / photo._pinchStart;
        lastCircle.r = Math.max(5, photo._r0 * scale);
        $('#radiusSlider').value = Math.round(lastCircle.r);
        redraw(); updateReadouts();
      }
    });
    function clearPinch(){ pointers.clear(); photo._pinchStart = null; photo._r0 = null; }
    photo.addEventListener('pointerup', clearPinch);
    photo.addEventListener('pointerleave', clearPinch);
    photo.addEventListener('pointercancel', clearPinch);

    // Slider ±
    $('#radiusSlider').addEventListener('input', (e)=>{
      if(!lastCircle) return;
      lastCircle.r = parseInt(e.target.value||'0')||0;
      redraw(); updateReadouts();
    });
    $('#minus').addEventListener('click', ()=>{
      const s = $('#radiusSlider'); s.value = Math.max(parseInt(s.min), parseInt(s.value)-2); s.dispatchEvent(new Event('input'));
    });
    $('#plus').addEventListener('click', ()=>{
      const s = $('#radiusSlider'); s.value = Math.min(parseInt(s.max), parseInt(s.value)+2); s.dispatchEvent(new Event('input'));
    });

    // معايرة يدوية
    function computeScale(){
      if(!calibLine) return;
      const dx = calibLine.x2 - calibLine.x1;
      const dy = calibLine.y2 - calibLine.y1;
      const px = Math.hypot(dx,dy);
      const mm = parseFloat($('#knownMM').value||'0');
      if(mm > 0 && px > 5){
        scalePxPerMM = px/mm;
        $('#pxOut').textContent = 'px/مم: ' + scalePxPerMM.toFixed(2);
        updateReadouts();
      }else{
        alert('اكتبي طول مرجع صحيح وارسمى خط واضح.');
      }
    }
    $('#resetLine').addEventListener('click', ()=>{ calibLine=null; scalePxPerMM=null; $('#pxOut').textContent='px/مم: -'; redraw(); updateReadouts(); });

    // ======= التقاط خط المسطرة تلقائيًا =======
    async function autoRuler(){
      if(!window.cv || !cv.cvtColor){ alert('OpenCV لم يحمّل بعد'); return; }
      const w = photo.width, h = photo.height;
      if(!w || !h){ alert('اعملي "عرض على اللوحة" أولًا'); return; }

      const src = new cv.Mat(h, w, cv.CV_8UC4);
      cv.imread(photo, src);
      const gray = new cv.Mat(); cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
      const blur = new cv.Mat(); cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0);
      const edges = new cv.Mat(); cv.Canny(blur, edges, 50, 150, 3, false);

      // ابحث عن خطوط طويلة أفقية (أعلى الصورة غالبًا مكان المسطرة)
      const lines = new cv.Mat();
      cv.HoughLinesP(edges, lines, 1, Math.PI/180, 80, Math.round(w*0.15), Math.round(w*0.01));

      let best = null;
      for (let i = 0; i < lines.rows; ++i) {
        const x1 = lines.data32S[i*4], y1 = lines.data32S[i*4+1], x2 = lines.data32S[i*4+2], y2 = lines.data32S[i*4+3];
        const dx = x2 - x1, dy = y2 - y1;
        const len = Math.hypot(dx,dy);
        const slopeOK = Math.abs(dy) <= Math.abs(dx) * 0.2; // أفقي تقريبًا
        const inTopHalf = ((y1 + y2) / 2) < h * 0.6;        // في النصف العلوي غالبًا
        if(slopeOK && inTopHalf && len > (best?.len || 0)){
          best = {x1,y1,x2,y2,len};
        }
      }

      src.delete(); gray.delete(); blur.delete(); edges.delete(); lines.delete();

      if(!best){
        alert('لم أستطع التقاط خط المسطرة تلقائيًا. جربي أن تكون المسطرة واضحة وأفقية، أو ارسمى الخط يدويًا.');
        return;
      }

      calibLine = best;
      redraw();

      // اضبطي px/mm بناءً على "طول المرجع (مم)"
      const dx = best.x2 - best.x1, dy = best.y2 - best.y1;
      const pxLen = Math.hypot(dx,dy);
      const mm = parseFloat($('#knownMM').value||'0');
      if(mm > 0){
        scalePxPerMM = pxLen / mm;
        $('#pxOut').textContent = 'px/مم: ' + scalePxPerMM.toFixed(2);
        updateReadouts();
      } else {
        alert('تم التقاط خط المسطرة. أدخلي طول المرجع (مم) ليتم التحويل إلى ملم.');
      }
    }

    // ======= اكتشاف القزحية + ملم =======
    async function autoDetectCore(){
      if(!window.cv || !cv.cvtColor){ alert('OpenCV لم يحمّل بعد'); return false; }
      const w = photo.width, h = photo.height;
      if(!w || !h){ alert('اعملي "عرض على اللوحة" أولًا'); return false; }
      const src = new cv.Mat(h, w, cv.CV_8UC4);
      try{ cv.imread(photo, src); }catch{ alert('تعذّر قراءة الصورة'); return false; }
      const gray = new cv.Mat(); cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
      const blur = new cv.Mat(); cv.medianBlur(gray, blur, 5);
      const circles = new cv.Mat();
      const dp = 1.2, minDist = Math.round(Math.min(w,h)/8), param1 = 100, param2 = 80;
      const minRadius = Math.round(Math.min(w,h)/16), maxRadius = Math.round(Math.min(w,h)/3);
      cv.HoughCircles(blur, circles, cv.HOUGH_GRADIENT, dp, minDist, param1, param2, minRadius, maxRadius);
      if(circles.cols > 0){
        const x = circles.data32F[0]; const y = circles.data32F[1]; const r = circles.data32F[2];
        lastCircle = {x,y,r};
        $('#radiusSlider').value = Math.round(r);
        redraw();
        src.delete(); gray.delete(); blur.delete(); circles.delete();
        return true;
      } else {
        src.delete(); gray.delete(); blur.delete(); circles.delete();
        alert('لم يتم العثور على دائرة مناسبة.');
        return false;
      }
    }
    async function autoAll(){
      const ok = await autoDetectCore();
      if(!ok) return;
      if(scalePxPerMM){
        updateReadouts();
      }else{
        // لو لسه مفيش معايرة، نجرب نلتقط المسطرة تلقائيًا
        await autoRuler();
        updateReadouts();
        if(!scalePxPerMM){
          alert('لم تتم المعايرة بعد. يمكنك إدخال "طول المرجع (مم)" ثم الضغط على "التقاط خط المسطرة تلقائيًا" أو رسم الخط يدويًا.');
        }
      }
    }

    $('#btnAutoRuler').addEventListener('click', autoRuler);
    $('#btnAutoAll').addEventListener('click', autoAll);

  </script>
</body>
</html>
