<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<title>Ù‚ÙŠØ§Ø³ Ù‚Ø·Ø± Ø§Ù„Ù‚Ø²Ø­ÙŠØ© â€” V7.2 (ÙˆØ¶Ø¹ Ø§Ù„ØªØ­Ø±ÙŠÙƒ + Ù„Ù…Ø³)</title>
<style>
  :root { --pad: 12px; --radius: 12px; }
  html, body { margin:0; padding:0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Naskh Arabic UI", "Helvetica Neue", Arial, "Noto Color Emoji", sans-serif; background:#0b0f14; color:#e8eef6; }
  header { padding: var(--pad); text-align:center; background:#0f1720; position:sticky; top:0; z-index:5; border-bottom:1px solid #1f2a36; }
  header h1 { margin:0; font-size: 1.1rem; }
  main { padding: var(--pad); display: grid; gap: 16px; max-width: 980px; margin: 0 auto; }
  section { background:#0f1720; border:1px solid #1f2a36; border-radius: var(--radius); padding: var(--pad); }
  .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  label { font-size: .9rem; opacity:.9; }
  input, select, textarea, button { border-radius: 10px; border:1px solid #223246; background:#111b27; color:#e8eef6; padding:10px 12px; font-size:16px; }
  input:focus, textarea:focus, button:focus { outline: 2px solid #2c7be5; }
  button { cursor:pointer; }
  button.primary { background:#2c7be5; border-color:#2c7be5; color:white; }
  button.ghost { background:transparent; }
  .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
  .badge { padding:2px 8px; border-radius:999px; background:#142034; border:1px solid #24364a; font-size:.75rem; }
  canvas, img.preview { width: 100%; max-height: 70vh; border-radius: 12px; background:#02060a; object-fit: contain; touch-action: none; }
  .floating-hint { position:absolute; left:12px; top:56px; font-size:.9rem; color:#9fb4cc; background:#0b1520; border:1px solid #1e2c3c; padding:6px 10px; border-radius:10px; }
  .canvas-wrap { position: relative; }
  .status { margin-inline-start:auto; }
  @media (max-width: 680px){ .grid2 { grid-template-columns: 1fr; } }
</style>
</head>
<body>
  <header>
    <h1>ğŸ§¿ Ù‚ÙŠØ§Ø³ Ù‚Ø·Ø± Ø§Ù„Ù‚Ø²Ø­ÙŠØ© â€” V7.2 (ÙˆØ¶Ø¹ Ø§Ù„ØªØ­Ø±ÙŠÙƒ + Ù„Ù…Ø³)</h1>
  </header>

  <main>
    <section>
      <div class="row">
        <div class="hint">Ø¬Ø¯ÙŠØ¯: Ø²Ø± <b>ÙˆØ¶Ø¹ Ø§Ù„ØªØ­Ø±ÙŠÙƒ</b> â€” Ù„Ù…Ø§ ØªØ´ØºÙ‘Ù„Ù‡ ØªÙ‚Ø¯Ø± ØªØ­Ø±Ù‘Ùƒ Ø§Ù„Ø¯Ø§Ø¦Ø±Ø© Ø¨Ø§Ù„Ø³Ø­Ø¨ Ù…Ù† Ø£ÙŠ Ù…ÙƒØ§Ù† Ø¹Ù„Ù‰ Ø§Ù„Ù„ÙˆØ­Ø©. ÙˆØ¥Ù„Ø§Ù‘: Ø§Ø³Ø­Ø¨ <b>Ø¯Ø§Ø®Ù„ Ø§Ù„Ø¯Ø§Ø¦Ø±Ø©</b> Ù„Ù„ØªØ­Ø±ÙŠÙƒØŒ ÙˆØ¹Ù„Ù‰ <b>Ø§Ù„Ø­Ø§ÙØ©</b> Ù„Ù„ØªÙƒØ¨ÙŠØ±/Ø§Ù„ØªØµØºÙŠØ±ØŒ Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ù… <b>Pinch</b>.</div>
        <span id="moveBadge" class="badge status" style="display:none;">ÙˆØ¶Ø¹ Ø§Ù„ØªØ­Ø±ÙŠÙƒ: Ù…ÙØ¹Ù„</span>
      </div>
    </section>

    <section id="upload">
      <h3>Ø±ÙØ¹ ØµÙˆØ±Ø©</h3>
      <div class="row">
        <input id="file" type="file" accept="image/*">
        <button id="btnToCanvas" class="primary">Ø¹Ø±Ø¶ Ø¹Ù„Ù‰ Ø§Ù„Ù„ÙˆØ­Ø©</button>
        <button id="toggleMove" class="ghost">ÙˆØ¶Ø¹ Ø§Ù„ØªØ­Ø±ÙŠÙƒ: Ø¥ÙŠÙ‚Ø§Ù</button>
      </div>
      <div class="grid2" style="margin-top:8px;">
        <img id="preview" class="preview" alt="Ù…Ø¹Ø§ÙŠÙ†Ø© (Ù‚Ø¨Ù„ Ø§Ù„Ø±Ø³Ù…)">
        <div class="canvas-wrap">
          <div id="moveHint" class="floating-hint" style="display:none;">Ø§Ø³Ø­Ø¨ Ø¯Ø§Ø®Ù„ Ø§Ù„Ø¯Ø§Ø¦Ø±Ø© Ù„Ù„ØªØ­Ø±ÙŠÙƒ â€¢ Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø§ÙØ© Ù„Ù„ØªÙƒØ¨ÙŠØ±/Ø§Ù„ØªØµØºÙŠØ± â€¢ Ø£Ùˆ Pinch</div>
          <canvas id="photo"></canvas>
        </div>
      </div>
      <div id="errorMsg" class="error"></div>
    </section>

    <section id="controls">
      <h3>Ø§Ù„Ù…Ø¹Ø§ÙŠØ±Ø© ÙˆØ§Ù„Ù‚ÙŠØ§Ø³</h3>
      <div class="row">
        <span>Ø·ÙˆÙ„ Ø§Ù„Ù…Ø±Ø¬Ø¹ (Ù…Ù…):</span>
        <input id="knownMM" type="number" step="0.01" value="10" style="width:110px">
        <button id="resetLine">Ù…Ø³Ø­ Ø®Ø· Ø§Ù„Ù…Ø¹Ø§ÙŠØ±Ø©</button>
      </div>
      <div class="row" style="margin-top:8px;">
        <button id="autoDetect" class="primary">Ø§ÙƒØªØ´Ø§Ù ØªÙ„Ù‚Ø§Ø¦ÙŠ (OpenCV)</button>
        <button id="manualCircle">Ø±Ø³Ù… Ø¯Ø§Ø¦Ø±Ø© ÙŠØ¯ÙˆÙŠ (Ù£ Ù†Ù‚Ø§Ø·)</button>
        <button id="undoPt" class="ghost">ØªØ±Ø§Ø¬Ø¹ Ø¹Ù† Ø§Ù„Ù†Ù‚Ø·Ø©</button>
        <button id="clearCircle" class="ghost">Ù…Ø³Ø­ Ø§Ù„Ø¯Ø§Ø¦Ø±Ø©</button>
        <label>Threshold: <input id="th" type="range" min="10" max="200" value="80"> <span id="thVal">80</span></label>
      </div>
      <div class="row">
        <span id="diameterOut" class="badge">Ø§Ù„Ù‚Ø·Ø±: -</span>
        <span id="pxOut" class="badge">px/Ù…Ù…: -</span>
        <span id="centerOut" class="badge">Ø§Ù„Ù…Ø±ÙƒØ²: -</span>
        <span id="radiusOut" class="badge">Ù†ØµÙ Ø§Ù„Ù‚Ø·Ø±(px): -</span>
      </div>
    </section>

    <footer>Â© 2025 â€” Ø£Ø¯Ø§Ø© Ù‚ÙŠØ§Ø³ Ø§Ù„Ù‚Ø²Ø­ÙŠØ© â€” V7.2</footer>
  </main>

  <div id="toast"></div>

  <!-- OpenCV.js CDN -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>

  <script>
    const $ = (sel) => document.querySelector(sel);
    const preview = $('#preview');
    const photo = $('#photo');
    const ctx = photo.getContext('2d', { willReadFrequently: true });
    const moveHint = $('#moveHint');
    const moveBadge = $('#moveBadge');

    let calibLine = null, scalePxPerMM = null, manualPts = [];
    let lastCircle = null, baseCanvas = null;
    let dragMode = null, activeId = null, startPos = null, startCircle = null;
    const HANDLE_R = 18;
    const INSIDE_MARGIN = 24; // move if within r + margin
    let moveMode = false;     // NEW

    function toast(msg){ const t=$('#toast'); t.textContent=msg; t.style.display='block'; setTimeout(()=>t.style.display='none',1800); }
    function getCanvasXY(evt){
      const rect = photo.getBoundingClientRect();
      const sx = photo.width / rect.width;
      const sy = photo.height / rect.height;
      return { x: (evt.clientX - rect.left) * sx, y: (evt.clientY - rect.top) * sy };
    }
    function redraw(){
      if(!baseCanvas) return;
      ctx.clearRect(0,0,photo.width,photo.height);
      ctx.drawImage(baseCanvas, 0, 0);
      if(calibLine){
        ctx.beginPath(); ctx.moveTo(calibLine.x1, calibLine.y1); ctx.lineTo(calibLine.x2, calibLine.y2);
        ctx.strokeStyle='#7be27b'; ctx.lineWidth=2; ctx.stroke();
      }
      if(manualPts.length){
        ctx.fillStyle='#ffd166';
        manualPts.forEach((p,i)=>{ ctx.beginPath(); ctx.arc(p.x,p.y,4,0,Math.PI*2); ctx.fill(); ctx.font='12px ui-monospace'; ctx.fillText(String(i+1),p.x+6,p.y-6); });
      }
      if(lastCircle){
        ctx.beginPath(); ctx.arc(lastCircle.x,lastCircle.y,lastCircle.r,0,Math.PI*2);
        ctx.lineWidth=2; ctx.strokeStyle='#2c7be5'; ctx.stroke();
        const hx = lastCircle.x + lastCircle.r, hy = lastCircle.y;
        // center handle
        ctx.beginPath(); ctx.arc(lastCircle.x,lastCircle.y,HANDLE_R,0,Math.PI*2);
        ctx.fillStyle='rgba(123,226,123,0.25)'; ctx.fill(); ctx.strokeStyle='#7be27b'; ctx.stroke();
        // rim handle
        ctx.beginPath(); ctx.arc(hx,hy,HANDLE_R,0,Math.PI*2);
        ctx.fillStyle='rgba(255,209,102,0.25)'; ctx.fill(); ctx.strokeStyle='#ffd166'; ctx.stroke();
      }
    }
    function updateOutputs(){
      if(!lastCircle){ $('#centerOut').textContent='Ø§Ù„Ù…Ø±ÙƒØ²: -'; $('#radiusOut').textContent='Ù†ØµÙ Ø§Ù„Ù‚Ø·Ø±(px): -'; $('#diameterOut').textContent='Ø§Ù„Ù‚Ø·Ø±: -'; moveHint.style.display='none'; return; }
      $('#centerOut').textContent = 'Ø§Ù„Ù…Ø±ÙƒØ²: ('+lastCircle.x.toFixed(1)+', '+lastCircle.y.toFixed(1)+')';
      $('#radiusOut').textContent = 'Ù†ØµÙ Ø§Ù„Ù‚Ø·Ø±(px): '+lastCircle.r.toFixed(1);
      const pxDiameter = 2*lastCircle.r;
      if(scalePxPerMM){ $('#diameterOut').textContent = 'Ø§Ù„Ù‚Ø·Ø±: '+(pxDiameter/scalePxPerMM).toFixed(2)+' Ù…Ù…'; }
      else { $('#diameterOut').textContent = 'Ø§Ù„Ù‚Ø·Ø± (Ø¨Ø¯ÙˆÙ† Ù…Ø¹Ø§ÙŠØ±Ø©): '+pxDiameter.toFixed(1)+' px'; }
      moveHint.style.display='block';
    }

    // Toggle move mode
    $('#toggleMove').addEventListener('click', ()=>{
      moveMode = !moveMode;
      $('#toggleMove').textContent = 'ÙˆØ¶Ø¹ Ø§Ù„ØªØ­Ø±ÙŠÙƒ: ' + (moveMode ? 'ØªØ´ØºÙŠÙ„' : 'Ø¥ÙŠÙ‚Ø§Ù');
      moveBadge.style.display = moveMode ? 'inline-block' : 'none';
      toast(moveMode ? 'ÙˆØ¶Ø¹ Ø§Ù„ØªØ­Ø±ÙŠÙƒ Ù…ÙØ¹Ù„ â€” Ø§Ø³Ø­Ø¨ Ø¨Ø£ÙŠ Ù…ÙƒØ§Ù†' : 'ØªÙ… Ø¥ÙŠÙ‚Ø§Ù ÙˆØ¶Ø¹ Ø§Ù„ØªØ­Ø±ÙŠÙƒ');
    });

    // Image load
    $('#file').addEventListener('change', (ev)=>{
      const f = ev.target.files && ev.target.files[0];
      if(!f){ toast('Ù„Ù… ÙŠØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ù…Ù„Ù'); return; }
      if(!/^image\//.test(f.type||'')){ $('#errorMsg').textContent='Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø®ØªØ§Ø± Ù„ÙŠØ³ ØµÙˆØ±Ø©'; return; }
      const url = URL.createObjectURL(f);
      preview.src = url;
      preview.onload = ()=> toast('ØªÙ…Øª Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© â€” Ø§Ø¶ØºØ· "Ø¹Ø±Ø¶ Ø¹Ù„Ù‰ Ø§Ù„Ù„ÙˆØ­Ø©"');
      preview.onerror = ()=> $('#errorMsg').textContent='ØªØ¹Ø°Ù‘Ø± Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„ØµÙˆØ±Ø©.';
    });

    $('#btnToCanvas').addEventListener('click', ()=>{
      if(!preview.src){ toast('Ø§Ø®ØªØ± ØµÙˆØ±Ø© Ø£ÙˆÙ„Ù‹Ø§'); return; }
      const img = new Image();
      img.onload = ()=>{
        const maxW = 900;
        const scale = Math.min(1, maxW / img.width);
        const w = Math.max(1, Math.round(img.width*scale));
        const h = Math.max(1, Math.round(img.height*scale));
        photo.width=w; photo.height=h;
        ctx.clearRect(0,0,w,h);
        ctx.drawImage(img,0,0,w,h);
        baseCanvas = document.createElement('canvas');
        baseCanvas.width=w; baseCanvas.height=h;
        baseCanvas.getContext('2d').drawImage(img,0,0,w,h);
        calibLine=null; manualPts=[]; lastCircle=null; scalePxPerMM=null;
        $('#pxOut').textContent='px/Ù…Ù…: -'; updateOutputs();
        toast('ØªÙ… Ø¹Ø±Ø¶ Ø§Ù„ØµÙˆØ±Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù„ÙˆØ­Ø©');
      };
      img.src = preview.src;
    });

    // Manual circle
    function circumcircle(p1,p2,p3){
      const x1=p1.x, y1=p1.y, x2=p2.x, y2=p2.y, x3=p3.x, y3=p3.y;
      const A = x1*(y2 - y3) - y1*(x2 - x3) + x2*y3 - x3*y2;
      if(Math.abs(A) < 1e-6) return null;
      const Bx = ((x1*x1 + y1*y1)*(y2 - y3) + (x2*x2 + y2*y2)*(y3 - y1) + (x3*x3 + y3*y3)*(y1 - y2)) / (2*A);
      const By = ((x1*x1 + y1*y1)*(x3 - x2) + (x2*x2 + y2*y2)*(x1 - x3) + (x3*x3 + y3*y3)*(x2 - x1)) / (2*A);
      const r = Math.hypot(x1 - Bx, y1 - By);
      return {x: Bx, y: By, r};
    }
    $('#manualCircle').addEventListener('click', (e)=>{
      if(e.target.dataset.active === '1'){
        e.target.dataset.active='0'; e.target.textContent='Ø±Ø³Ù… Ø¯Ø§Ø¦Ø±Ø© ÙŠØ¯ÙˆÙŠ (Ù£ Ù†Ù‚Ø§Ø·)';
        toast('Ø®Ø±ÙˆØ¬ Ù…Ù† ÙˆØ¶Ø¹ Ø§Ù„ÙŠØ¯ÙˆÙŠ');
      }else{
        e.target.dataset.active='1'; e.target.textContent='â€” ÙˆØ¶Ø¹ Ø§Ù„ÙŠØ¯ÙˆÙŠ: Ø§Ø¶ØºØ· Ù£ Ù†Ù‚Ø§Ø· Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø§ÙØ© â€”';
        manualPts=[]; lastCircle=null; redraw(); toast('Ø§Ø¯Ø®Ù„ ÙˆØ¶Ø¹ Ø§Ù„ÙŠØ¯ÙˆÙŠ');
      }
    });
    $('#undoPt').addEventListener('click', ()=>{ if(manualPts.length){ manualPts.pop(); redraw(); }});
    $('#clearCircle').addEventListener('click', ()=>{ lastCircle=null; redraw(); updateOutputs(); });

    // Pointer handling
    const pointers = new Map(); // id -> {x,y}
    function onPointerDown(e){
      if(!baseCanvas) { toast('Ø§Ø¹Ø±Ø¶ Ø§Ù„ØµÙˆØ±Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù„ÙˆØ­Ø© Ø£ÙˆÙ„Ù‹Ø§'); return; }
      photo.setPointerCapture(e.pointerId);
      const pos = getCanvasXY(e);
      pointers.set(e.pointerId, pos);

      if($('#manualCircle').dataset.active === '1'){
        manualPts.push(pos); redraw();
        if(manualPts.length === 3){
          const c = circumcircle(manualPts[0], manualPts[1], manualPts[2]);
          if(c){ lastCircle = c; redraw(); updateOutputs(); }
          else { alert('Ø§Ù„Ù†Ù‚Ø§Ø· Ø´Ø¨Ù‡ Ø¹Ù„Ù‰ Ø®Ø· ÙˆØ§Ø­Ø¯ â€” Ø§Ø®ØªÙØ± Ù£ Ù†Ù‚Ø§Ø· Ù…ÙˆØ²Ù‘Ø¹Ø©.'); }
          manualPts=[]; const btn=$('#manualCircle'); btn.dataset.active='0'; btn.textContent='Ø±Ø³Ù… Ø¯Ø§Ø¦Ø±Ø© ÙŠØ¯ÙˆÙŠ (Ù£ Ù†Ù‚Ø§Ø·)';
        }
        return;
      }

      // Pinch start
      if(pointers.size === 2 && lastCircle){
        dragMode = 'pinch'; activeId = null;
        startCircle = {...lastCircle};
        const [p1,p2] = Array.from(pointers.values());
        startPos = {d: Math.hypot(p1.x - p2.x, p1.y - p2.y)};
        return;
      }

      if(lastCircle){
        const distToCenter = Math.hypot(pos.x - lastCircle.x, pos.y - lastCircle.y);
        const insideWide = distToCenter <= (lastCircle.r + INSIDE_MARGIN);
        const rimPoint = {x: lastCircle.x + lastCircle.r, y: lastCircle.y};
        const nearRim = Math.hypot(pos.x - rimPoint.x, pos.y - rimPoint.y) <= HANDLE_R || Math.abs(distToCenter - lastCircle.r) <= HANDLE_R;

        // Move mode forces moving anywhere
        if(moveMode){ dragMode='move'; activeId=e.pointerId; startPos=pos; startCircle={...lastCircle}; return; }

        if(nearRim){ dragMode='resize'; activeId=e.pointerId; startPos=pos; startCircle={...lastCircle}; return; }
        if(insideWide){ dragMode='move'; activeId=e.pointerId; startPos=pos; startCircle={...lastCircle}; return; }
      }

      // Calibration
      calibLine = {x1:pos.x, y1:pos.y, x2:pos.x, y2:pos.y, dragging:true};
      redraw();
    }
    function onPointerMove(e){
      const pos = getCanvasXY(e);
      pointers.set(e.pointerId, pos);

      if(dragMode === 'pinch' && lastCircle && pointers.size>=2){
        const [p1,p2] = Array.from(pointers.values());
        const d = Math.hypot(p1.x - p2.x, p1.y - p2.y);
        if(startPos && startPos.d > 5){
          const scale = d / startPos.d;
          lastCircle.r = Math.max(5, startCircle.r * scale);
          redraw(); updateOutputs(); return;
        }
      }
      if(dragMode === 'move' && lastCircle && (moveMode || e.pointerId === activeId)){
        const dx = pos.x - startPos.x;
        const dy = pos.y - startPos.y;
        lastCircle.x = startCircle.x + dx;
        lastCircle.y = startCircle.y + dy;
        redraw(); updateOutputs(); return;
      }
      if(dragMode === 'resize' && e.pointerId === activeId && lastCircle){
        const r = Math.hypot(pos.x - startCircle.x, pos.y - startCircle.y);
        lastCircle.r = Math.max(5, r);
        redraw(); updateOutputs(); return;
      }
      if(calibLine && calibLine.dragging){
        calibLine.x2 = pos.x; calibLine.y2 = pos.y; redraw(); return;
      }
    }
    function onPointerUp(e){
      pointers.delete(e.pointerId);
      if(dragMode && (e.pointerId === activeId || dragMode==='pinch')){ dragMode=null; activeId=null; startPos=null; startCircle=null; }
      if(calibLine){ calibLine.dragging=false; computeScale(); }
    }
    photo.addEventListener('pointerdown', onPointerDown);
    photo.addEventListener('pointermove', onPointerMove);
    photo.addEventListener('pointerup', onPointerUp);
    photo.addEventListener('pointercancel', onPointerUp);
    photo.addEventListener('pointerleave', onPointerUp);

    // Calibration & Auto detect
    function computeScale(){
      if(!calibLine) return;
      const dx = calibLine.x2 - calibLine.x1;
      const dy = calibLine.y2 - calibLine.y1;
      const px = Math.hypot(dx,dy);
      const mm = parseFloat($('#knownMM').value||'0');
      if(mm > 0 && px > 5){
        scalePxPerMM = px/mm;
        $('#pxOut').textContent = 'px/Ù…Ù…: ' + scalePxPerMM.toFixed(2);
        updateOutputs();
        toast('ØªÙ… Ø¶Ø¨Ø· Ø§Ù„Ù…Ù‚ÙŠØ§Ø³');
      }else{
        alert('ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¯Ø®Ø§Ù„ Ø·ÙˆÙ„ Ù…Ø±Ø¬Ø¹ ØµØ­ÙŠØ­ ÙˆØ±Ø³Ù… Ø®Ø· ÙˆØ§Ø¶Ø­.');
      }
    }
    async function autoDetect(){
      if(!window.cv || !cv.cvtColor){ alert('Ù„Ù… ÙŠØªÙ… ØªØ­Ù…ÙŠÙ„ OpenCV Ø¨Ø¹Ø¯.'); return; }
      const w = photo.width, h = photo.height;
      if(!w || !h){ alert('Ø§Ø¹Ø±Ø¶ Ø§Ù„ØµÙˆØ±Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù„ÙˆØ­Ø© Ø£ÙˆÙ„Ù‹Ø§.'); return; }
      const src = new cv.Mat(h, w, cv.CV_8UC4);
      try{ cv.imread(photo, src); }catch(e){ alert('ØªØ¹Ø°Ù‘Ø± Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„ØµÙˆØ±Ø© Ø¨ÙˆØ§Ø³Ø·Ø© OpenCV'); return; }
      const gray = new cv.Mat(); cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
      const blur = new cv.Mat(); cv.medianBlur(gray, blur, 5);
      const circles = new cv.Mat();
      const dp = 1.2;
      const minDist = Math.round(Math.min(w,h)/8);
      const param1 = 100;
      const param2 = parseInt($('#th').value);
      const minRadius = Math.round(Math.min(w,h)/16);
      const maxRadius = Math.round(Math.min(w,h)/3);
      cv.HoughCircles(blur, circles, cv.HOUGH_GRADIENT, dp, minDist, param1, param2, minRadius, maxRadius);
      lastCircle = null;
      for (let i = 0; i < circles.cols; ++i) {
        const x = circles.data32F[i*3];
        const y = circles.data32F[i*3+1];
        const r = circles.data32F[i*3+2];
        if(!lastCircle || Math.abs(x-w/2)+Math.abs(y-h/2) < Math.abs(lastCircle.x-w/2)+Math.abs(lastCircle.y-w/2)){
          lastCircle = {x, y, r};
        }
      }
      src.delete(); gray.delete(); blur.delete(); circles.delete();
      if(lastCircle){ redraw(); updateOutputs(); toast('ØªÙ… Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ù‚Ø²Ø­ÙŠØ© â€” ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„ØªØ­Ø±ÙŠÙƒ/Ø§Ù„ØªÙƒØ¨ÙŠØ± Ø§Ù„Ø¢Ù†'); }
      else { alert('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¯Ø§Ø¦Ø±Ø© Ù…Ù†Ø§Ø³Ø¨Ø©.'); }
    }
    $('#autoDetect').addEventListener('click', autoDetect);
    $('#th').addEventListener('input', (e)=> $('#thVal').textContent = e.target.value);
    $('#resetLine').addEventListener('click', ()=>{ calibLine=null; redraw(); $('#pxOut').textContent='px/Ù…Ù…: -'; });

  </script>
</body>
</html>
